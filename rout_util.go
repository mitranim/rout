package rout

import (
	"errors"
	"fmt"
	r "reflect"
	"regexp"
	"strings"
	"sync"
	u "unsafe"
)

const (
	segmentPattern  = `([^/?#]+)`
	segmentTemplate = `{}`
	subsCap         = 8
)

var regexpCache sync.Map

// Susceptible to "thundering herd" but probably good enough.
func cachedRegexp(pattern string) *regexp.Regexp {
	val, ok := regexpCache.Load(pattern)
	if ok {
		return val.(*regexp.Regexp)
	}

	reg := regexp.MustCompile(pattern)
	regexpCache.Store(pattern, reg)
	return reg
}

var patCache sync.Map

// Susceptible to "thundering herd" but probably good enough.
func cachedPat(pattern string) Pat {
	val, ok := patCache.Load(pattern)
	if ok {
		return val.(Pat)
	}

	var pat Pat
	try(pat.Parse(pattern))
	patCache.Store(pattern, pat)
	return pat
}

func try(err error) {
	if err != nil {
		panic(err)
	}
}

func rec(ptr *error) {
	err := toErr(recover())
	if err != nil {
		*ptr = err
	}
}

func toErr(val interface{}) error {
	if val == nil {
		return nil
	}
	err, _ := val.(error)
	if err != nil {
		return err
	}
	return nonErr{val}
}

type nonErr [1]interface{}

func (self nonErr) Error() string {
	if self[0] != nil {
		return fmt.Sprint(self[0])
	}
	return ``
}

func hasSlashPrefix(val string) bool {
	return len(val) > 0 && val[0] == '/'
}

func hasSlashSuffix(val string) bool {
	return len(val) > 0 && val[len(val)-1] == '/'
}

func errStatusDeep(err error) int {
	for err != nil {
		impl, _ := err.(interface{ HttpStatusCode() int })
		if impl != nil {
			return impl.HttpStatusCode()
		}
		err = errUnwrap(err)
	}
	return 0
}

/*
Improved version of `errors.Unwrap` which returns nil if the error incorrectly
unwraps to itself, to avoid an infinite loop.
*/
func errUnwrap(err error) error {
	cause := errors.Unwrap(err)
	if cause == nil || r.DeepEqual(err, cause) {
		return nil
	}
	return cause
}

func intLen(val int) (count int) {
	if val < 0 {
		count++
	}
	for {
		count++
		val /= 10
		if val == 0 {
			break
		}
	}
	return
}

/*
Allocation-free conversion. Reinterprets a byte slice as a string. Borrowed from
the standard library. Reasonably safe. Should not be used when the underlying
byte array is volatile, for example part of a scratch buffer in SQL scanning.
*/
func bytesString(val []byte) string {
	return *(*string)(u.Pointer(&val))
}

// TODO consider caching.
func exaToReg(src string) string {
	return `^` + regexp.QuoteMeta(src) + `$`
}

// TODO consider caching.
func staToReg(src string) string {
	return `^` + regexp.QuoteMeta(src)
}

// TODO consider caching.
func patToReg(src string) string {
	return cachedPat(src).Reg()
}

/*
AFAIK OAS patterns have no way to "escape" template expressions.
Which means we can't convert it, but we can validate it.
*/
func exactToPat(src string) string {
	if strings.ContainsAny(src, `{}?#`) {
		panic(fmt.Errorf(
			`[rout] pattern %q contains special characters and can't be converted to an OAS pattern`,
			src,
		))
	}
	return src
}

// Copied from `github.com/mitranim/gax` and tested there.
func growBytes(prev []byte, size int) []byte {
	len, cap := len(prev), cap(prev)
	if cap-len >= size {
		return prev
	}

	// Similar to the usual slice growth rules. May allocate more than asked.
	next := make([]byte, len, 2*cap+size)
	copy(next, prev)
	return next
}

/*
Estimates the length of `Pat` that would be generated by parsing the given
pattern. Assumes a well-formed pattern. For invalid patterns, this may result
in some wasted allocations. We assume that all patterns are small, hardcoded,
and valid, and optimize for that case.
*/
func patLen(src string) (out int) {
	hit := false

	for _, char := range src {
		switch char {
		case '{':
			out++
			hit = true

		case '}':
			hit = false

		default:
			if !hit {
				out++
				hit = true
			}
		}
	}

	return
}

// Short for "submatches". Used by `Pat` when matching strings.
type subs struct {
	buf [subsCap]string
	cur int
}

func (self *subs) add(val string) bool {
	if len(val) == 0 {
		return false
	}

	if self.cur < subsCap {
		self.buf[self.cur] = val
		self.cur++
		return true
	}

	return false
}

func (self *subs) slice() []string {
	return self.buf[:self.cur]
}

func strPop(ptr *string, cur int) (out string) {
	out, *ptr = (*ptr)[:cur], (*ptr)[cur:]
	return
}

func matchExa(pat, inp string) bool { return pat == inp }

func matchSta(pat, inp string) bool {
	return strings.HasPrefix(inp, pat) &&
		(len(inp) == len(pat) ||
			hasSlashSuffix(pat) ||
			hasSlashPrefix(inp[len(pat):]))
}

func matchReg(pat, inp string) bool {
	return cachedRegexp(pat).MatchString(inp)
}

func matchPat(pat, inp string) bool {
	return cachedPat(pat).Match(inp)
}

func submatchExa(pat, inp string) []string {
	if matchExa(pat, inp) {
		return []string{}
	}
	return nil
}

func submatchSta(pat, inp string) []string {
	if matchSta(pat, inp) {
		return []string{}
	}
	return nil
}

func submatchReg(pat, inp string) []string {
	match := cachedRegexp(pat).FindStringSubmatch(inp)
	if len(match) >= 1 {
		return match[1:]
	}
	return nil
}

func submatchPat(pat, inp string) []string {
	return cachedPat(pat).Submatch(inp)
}
