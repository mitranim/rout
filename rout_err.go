package rout

import (
	"errors"
	"fmt"
	"io"
	"net/http"
	"strings"
)

// The type of all errors generated by this package.
type Err struct {
	Cause  error `json:"cause"`
	Status int   `json:"status"`
}

// Implement `error`.
func (self Err) Error() string {
	var buf strings.Builder
	self.writeError(&buf)
	return buf.String()
}

// Implement a hidden interface in "errors".
func (self Err) Is(other error) bool {
	if self.Cause != nil {
		return errors.Is(self.Cause, other)
	}
	err, ok := other.(Err)
	return ok && self == err
}

// Implement a hidden interface in "errors".
func (self Err) Unwrap() error {
	return self.Cause
}

// Support verbose printing via `%+v`.
func (self Err) Format(fms fmt.State, verb rune) {
	if verb == 'v' && fms.Flag('+') {
		self.writeErrorVerbose(fms)
	} else {
		self.writeError(fms)
	}
}

func (self Err) writeError(out io.Writer) {
	self.writeErrorShallow(out)
	if self.Cause != nil {
		fmt.Fprintf(out, `: %v`, self.Cause)
	}
}

func (self Err) writeErrorShallow(out io.Writer) {
	fmt.Fprint(out, `routing error`)
	if self.Status != 0 {
		fmt.Fprintf(out, ` (HTTP status %v)`, self.Status)
	}
}

func (self Err) writeErrorVerbose(out io.Writer) {
	self.writeErrorShallow(out)
	if self.Cause != nil {
		fmt.Fprintf(out, `: %+v`, self.Cause)
	}
}

func errMethodNotAllowed(method, path string) error {
	return Err{
		Cause:  fmt.Errorf(`method not allowed: %v %q`, method, path),
		Status: http.StatusMethodNotAllowed,
	}
}

func errNotFound(method, path string) error {
	return Err{
		Cause:  fmt.Errorf(`no such endpoint: %v %q`, method, path),
		Status: http.StatusNotFound,
	}
}
